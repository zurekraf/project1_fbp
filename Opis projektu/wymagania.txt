Na wstępie uczciwie przyznam że aplikacja jest trywialna i mocno niedopracowana - niepoprawne wykorzystanie większości endpointów skutkuje błędem serwera (500), brak kodów odpowiedzi.

Włożyłem jednak trochę pracy w zaimplementowanie dodatkowych funkcjonaności - mam nadzieję że tee wady i zalety się zbilansują.


Zalety:

1. Zabezpieczenie endpointów:
	1.1 Wykorzystanie tokenów JWT (tylko i aż)
	1.2 Dostęp w oparciu o role (@PreAuthorize("hasAnyAuthority('ADMIN')") itp)
	1.3 W jednym przypadku wykorzystałem utworzony PermissionEvaluator (@PreAuthorize("hasPermission(#id, 'updateDefender')")) 
2. Token JWT przechowywany i przesyłany w formie Cookie (+dodanie filtru pobierającego wartość ciasteczka i dodanie go jako nagłówka odpowiedzi - modyfikacja przesyłanego żądania)
3. HATEOAS - niestety z wykorzystaniem spring-boot-starter-hateoas, co zmusiło mnie do pisania RepresentationModelAssemblerów. Finalnie dodawane linki umożliwiają jedynie sprawne nawigowanie po udostępnianych zasobach, jednak nie udało mi się wykorzystać ich w funkcjach POST/PUT, tak jak to ma miejsce przy korzystaniu z @RepositoryRestResource. Teraz już wiem że prawdpodobnie należało wykorzystać PagingAndSortingRepository i bibliotekę spring-data-jpa
4. Zastosowanie DTO, które w kulku przypadkach ukrywają lub dodają pola udostępnianych encji.